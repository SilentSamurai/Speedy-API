package com.github.silent.samurai.speedy.validation;

import com.github.silent.samurai.speedy.exceptions.BadRequestException;
import com.github.silent.samurai.speedy.interfaces.EntityMetadata;
import com.github.silent.samurai.speedy.interfaces.FieldMetadata;
import com.github.silent.samurai.speedy.interfaces.KeyFieldMetadata;
import com.github.silent.samurai.speedy.interfaces.SpeedyValue;
import com.github.silent.samurai.speedy.models.SpeedyEntity;
import com.github.silent.samurai.speedy.models.SpeedyEntityKey;
import com.github.silent.samurai.speedy.models.SpeedyNull;
import com.github.silent.samurai.speedy.validation.rules.*;

import java.util.ArrayList;
import java.util.List;

/**
 * Encapsulates the **default** entity/field validation logic that is applied when
 * no custom {@link com.github.silent.samurai.speedy.interfaces.ISpeedyCustomValidation}
 * is registered for the target entity.
 * <p>
 * This class was extracted from {@code ValidationProcessor} to isolate
 * responsibility and to make the high-level workflow easier to understand,
 * test and extend.
 * <p>
 * The class is stateless and therefore thread-safe; rule instances are kept
 * in an immutable list.
 */
public class DefaultFieldValidator {

    /**
     * Built-in rule set. The list can be overridden via the constructor for
     * testing or future extensibility.
     */
    private static final List<FieldRule> DEFAULT_RULES = List.of(
            new CollectionRule(),
            new AssociationRule(),
            new EnumRule(),
            new TypeCompatibilityRule(),
            new NonAssociationObjectRule()
    );

    private final List<FieldRule> fieldRules;

    public DefaultFieldValidator() {
        this.fieldRules = DEFAULT_RULES;
    }

    /* ---------------------------------------------------------------------- */
    /* Public API                                                             */
    /* ---------------------------------------------------------------------- */

    private static void throwIfErrors(List<String> errors) throws BadRequestException {
        if (!errors.isEmpty()) {
            throw new BadRequestException(String.join(" | ", errors));
        }
    }

    public void validateCreate(EntityMetadata entityMetadata, SpeedyEntity entity)
            throws BadRequestException {
        validate(entityMetadata, entity, true);
    }

    public void validateUpdate(EntityMetadata entityMetadata, SpeedyEntity entity)
            throws BadRequestException {
        validate(entityMetadata, entity, false);
    }

    /* ---------------------------------------------------------------------- */
    /* Internal helpers                                                       */
    /* ---------------------------------------------------------------------- */

    public void validateEntityKey(EntityMetadata entityMetadata, SpeedyEntityKey entityKey)
            throws BadRequestException {
        List<String> errors = new ArrayList<>();

        for (KeyFieldMetadata keyField : entityMetadata.getKeyFields()) {
            if (keyField.shouldGenerateKey()) continue; // auto-generated key

            if (!entityKey.has(keyField)) {
                errors.add("missing key field " + keyField.getOutputPropertyName());
                continue;
            }

            SpeedyValue val = entityKey.get(keyField);
            if (val == null || val instanceof SpeedyNull || val.isEmpty()) {
                errors.add("key field " + keyField.getOutputPropertyName() + " cannot be null or empty");
            }
        }

        throwIfErrors(errors);
    }

    private void validate(EntityMetadata entityMetadata,
                          SpeedyEntity entity,
                          boolean enforceRequired) throws BadRequestException {

        List<String> errors = new ArrayList<>();

        for (FieldMetadata field : entityMetadata.getAllFields()) {
            boolean autoGenerated = (field instanceof KeyFieldMetadata key && key.shouldGenerateKey())
                    || !field.isInsertable();

            boolean required = enforceRequired
                    && (field.isRequired() || !field.isNullable())
                    && !autoGenerated;

            boolean hasValue = entity.has(field);

            // 1. Missing required value ----------------------------------------
            if (required && !hasValue) {
                errors.add(field.getOutputPropertyName() + " is required");
                continue;
            }

            // 2. Null/empty value for required field --------------------------
            if (required && hasValue) {
                SpeedyValue value = entity.get(field);
                if (value == null || value instanceof SpeedyNull || value.isEmpty()) {
                    errors.add(field.getOutputPropertyName() + " cannot be null or empty");
                    continue;
                }
            }

            // 3. Optional field supplied â€“ run lightweight checks -------------
            if (!required && hasValue && !autoGenerated) {
                SpeedyValue value = entity.get(field);
                if (value != null && !(value instanceof SpeedyNull) && !value.isEmpty()) {
                    validateOptional(field, value, errors);
                }
            }
        }

        throwIfErrors(errors);
    }

    /**
     * Applies composable, lightweight rules to an optional (non-required)
     * field for which a value was provided.
     */
    private void validateOptional(FieldMetadata fieldMetadata, SpeedyValue value, List<String> errors) {
        for (FieldRule rule : fieldRules) {
            rule.validate(fieldMetadata, value, errors);
        }
    }
}
