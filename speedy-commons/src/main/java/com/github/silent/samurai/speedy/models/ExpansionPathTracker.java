package com.github.silent.samurai.speedy.models;

import com.github.silent.samurai.speedy.interfaces.EntityMetadata;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/// Tracks the current expansion path during recursive entity processing.
///
/// Used to support dot notation expansion (e.g., `Inventory.Product.Category`).
///
/// **Features**
/// - Path Tracking: Maintains the current expansion path using a stack (LIFO)
/// - Dot Notation Support: Generates paths like `Inventory.Product.Category`
/// - Backward Compatibility: Supports both dot notation and entity-based expansions
/// - Recursive Processing: Handles nested entity expansions efficiently
///
/// **Usage Example**
/// ```java
/// Set<String> expansions = Set.of("Inventory.Product", "Inventory.Product.Category");
/// ExpansionPathTracker tracker = new ExpansionPathTracker(expansions);
///
/// EntityMetadata inventory = getEntityMetadata("Inventory");
/// EntityMetadata product = getEntityMetadata("Product");
/// EntityMetadata category = getEntityMetadata("Category");
///
/// tracker.pushEntity(inventory);
/// tracker.pushEntity(product);
/// boolean shouldExpand = tracker.shouldExpand(category); // true
/// String currentPath = tracker.getCurrentDotPath(category); // "Product.Category"
/// int depth = tracker.getPathDepth(); // 2
/// tracker.popEntity(); // removes product
///```
public class ExpansionPathTracker {

    private final Deque<EntityMetadata> currentPath = new LinkedList<>();
    private final Set<String> requestedExpansions;

    public ExpansionPathTracker(Set<String> requestedExpansions) {
        if (requestedExpansions == null) {
            throw new IllegalArgumentException("Requested expansions cannot be null");
        }
        this.requestedExpansions = requestedExpansions;
    }

    /// Pushes an entity onto the current processing path (top of stack).
    ///
    /// @param entityMetadata the entity metadata being processed
    public void pushEntity(EntityMetadata entityMetadata) {
        if (entityMetadata == null) {
            throw new IllegalArgumentException("Entity metadata cannot be null");
        }
        currentPath.addLast(entityMetadata);
    }

    /// Pops the current entity from the processing path (top of stack).
    ///
    /// @return the removed entity metadata, or null if the path is empty
    public EntityMetadata popEntity() {
        return currentPath.pollLast();
    }

    /// Gets the current dot notation path including the specified association.
    /// The path is generated by concatenating entity names with dots, skipping the first entity.
    ///
    /// @param association the association to include in the path
    /// @return the current path as a dot-separated string, or empty string if path is empty
    public String getCurrentDotPath(EntityMetadata association) {
        if (association == null) {
            throw new IllegalArgumentException("Association cannot be null");
        }
        if (currentPath.isEmpty()) {
            return "";
        }
        // Build a path from the second element to the last, then append association
        return Stream.concat(
                        currentPath.stream().skip(1),
                        Stream.of(association)
                ).map(EntityMetadata::getName)
                .collect(Collectors.joining("."));
    }

    /// Checks if a specific association should be expanded based on the current path.
    /// This method checks both dot notation expansions (e.g., `Inventory.Product.Category`)
    /// and entity-based expansions (e.g., `Category`) for backward compatibility.
    ///
    /// @param association the association metadata to check for expansion
    /// @return true if the association should be expanded, false otherwise
    public boolean shouldExpand(EntityMetadata association) {
        if (association == null) {
            throw new IllegalArgumentException("Association cannot be null");
        }
        String fullPath = getCurrentDotPath(association);
        return requestedExpansions.contains(fullPath);
    }

    /// Gets the current path depth.
    ///
    /// @return the number of entities in the current path
    public int getPathDepth() {
        return currentPath.size();
    }

    /// Checks if the current path is empty.
    ///
    /// @return true if no entities are in the current path, false otherwise
    public boolean isEmpty() {
        return currentPath.isEmpty();
    }

    /// Gets the current entity at the top of the path without removing it.
    ///
    /// @return the current entity metadata, or null if path is empty
    public EntityMetadata getCurrentEntity() {
        return currentPath.peekLast();
    }

    /// Gets all entities in the current path as a defensive copy.
    ///
    /// @return a copy of the current path as a list
    public java.util.List<EntityMetadata> getCurrentPath() {
        return new java.util.ArrayList<>(currentPath);
    }

    /// Gets the set of requested expansions this tracker was initialized with.
    ///
    /// @return an unmodifiable view of the requested expansions
    public Set<String> getRequestedExpansions() {
        return java.util.Collections.unmodifiableSet(requestedExpansions);
    }
} 